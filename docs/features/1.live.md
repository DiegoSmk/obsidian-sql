# Live Tables (Tabelas Reativas) üîÑ

As **Live Tables** transformam o Obsidian de um editor est√°tico em um dashboard din√¢mico baseado em dados. Este documento detalha a arquitetura, o ciclo de vida e a gest√£o de identidade dos blocos reativos.

## 1. O Conceito de Bloco LIVE
Um bloco LIVE n√£o √© apenas um script; √© uma **View Sincronizada**. O c√≥digo SQL que gera os dados √© ocultado, dando lugar a uma interface de dados limpa e reativa.

### Contrato do Bloco LIVE
*   **Sintaxe**: Deve iniciar com `LIVE SELECT`.
*   **Atomicidade**: Cont√©m exatamente um comando `SELECT`.
*   **Imutabilidade**: √â estritamente *Read-Only*. Comandos como `INSERT`, `UPDATE`, `DELETE`, `CREATE`, `DROP`, `ALTER` ou `USE` s√£o bloqueados.

## 2. Gest√£o de Identidade e Sincroniza√ß√£o
Para garantir que os blocos reajam corretamente √†s mudan√ßas sem entrar em loops infinitos, usamos um sistema duplo de identifica√ß√£o:

### liveBlockId (Identidade Local)
*   **Defini√ß√£o**: Baseado na localiza√ß√£o f√≠sica (`notePath + lineStart + lineEnd`).
*   **Uso**: Serve para diagn√≥sticos e como um identificador de curto prazo durante a sess√£o atual.

### stableId (Identidade Persistente)
*   **Defini√ß√£o**: Um hash (SHA-256 parcial, truncado para os primeiros **16 caracteres**) baseado no conte√∫do da query e no caminho da nota.
*   **Uso**:
    *   **Ancoragem**: Vincula permanentemente um banco de dados espec√≠fico ao bloco (mesmo que ele seja movido de linha na nota).
    *   **OriginId**: Usado no `DatabaseChangeEvent` como o identificador definitivo da fonte da mudan√ßa. Por ser baseado no conte√∫do, √© mais robusto a pequenas edi√ß√µes no arquivo do que o `liveBlockId`.
    *   **Lifecycle**: Usado para gerenciar a limpeza de listeners no `EventBus`.

## 3. Arquitetura Reativa (DatabaseEventBus)
Usamos um Barramento de Eventos para evitar polling e garantir reatividade instant√¢nea.

### O Evento de Mudan√ßa
Sempre que uma query de escrita √© executada em qualquer lugar do plugin, um evento √© disparado:

```typescript
interface DatabaseChangeEvent {
    database: string;      // Banco que sofreu a altera√ß√£o
    tables: string[];      // Tabelas afetadas (extra√≠das via AST do SQL)
    timestamp: number;     // Hora da altera√ß√£o
    originId: string;      // stableId do bloco que gerou a altera√ß√£o
}
```

## 4. Ciclo de Vida do Bloco (Lifecycle)
O plugin utiliza a API oficial de `Component` do Obsidian (`ctx.addChild`) atrav√©s da classe `LiveSyncComponent`.

1.  **Montagem (Mount)**: O bloco registra seus listeners no `DatabaseEventBus`.
2.  **Rea√ß√£o**: Ao receber um evento, o bloco verifica:
    *   **Origem**: Se `event.originId === this.stableId`, ele ignora (preven√ß√£o de auto-refresh).
    *   **Banco**: O banco do evento deve ser o banco ancorado no bloco.
    *   **Tabelas**: O bloco s√≥ atualiza se uma das tabelas que ele observa foi modificada.
3.  **Desmontagem (Unmount)**: O `LiveSyncComponent` remove automaticamente os listeners, evitando vazamentos de mem√≥ria e "zombie listeners".

## 5. Extra√ß√£o de Tabelas (AST)
Para garantir precis√£o cir√∫rgica, o sistema utiliza o parser do **AlaSQL (AST - Abstract Syntax Tree)** em vez de Regex para identificar quais tabelas uma query observa. Isso permite lidar corretamente com JOINS, subqueries e aliases complexos.

---
*Documenta√ß√£o gerada a partir do planejamento original e refinada ap√≥s revis√£o t√©cnica de arquitetura.*
